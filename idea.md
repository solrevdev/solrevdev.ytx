# 1) .NET Global Tool (works with .NET 8 & 9)...
Exported on 30/08/2025 at 00:26:43 [from ChatGPT](https://chatgpt.com/c/68b09d19-ec5c-8328-8f9e-e4d8c27fba39) - with [SaveMyChatbot](https://save.hugocollin.com)

## User
Can I have a tool that given a YouTube url extracts the title description and full transcript. Ideally a plain html css and JavaScript tool or failing that a dotnet global tool to be installed .net 8 and 9 sdks supported OR and nox one liner   For example :    `json  {   "url" : "https://youtube.com/url",   "title": "the video title ",   "deacription": "the video description",   "transcriptRaw": "the video transcript raw text ", “transcript ”:”transcript with timestamps as urls to timestamped part of video full transcript but human readable markdown ” }`

## ChatGPT
Absolutely — here are two solid options you can run **today**:

* * *

1) .NET Global Tool (works with .NET 8 & 9)
===========================================

**What it does:**  
Given a YouTube URL, it prints a single JSON object like your example, including:

*   `url`
    
*   `title`
    
*   `description`
    
*   `transcriptRaw` (plain text)
    
*   `transcript` (Markdown with timestamped links)
    

It uses the excellent **YoutubeExplode** library to fetch metadata and captions (auto-generated or manual where available).

### Files

**`src/Ytx/Program.cs`**

```csharp
using System.Text;
using System.Text.Json;
using System.Text.RegularExpressions;
using YoutubeExplode;
using YoutubeExplode.Common;
using YoutubeExplode.Videos;
using YoutubeExplode.Videos.ClosedCaptions;

// tiny record for argv/JSON input
record Input(string url);

class Output
{
    public string url { get; set; } = "";
    public string title { get; set; } = "";
    public string description { get; set; } = "";
    public string transcriptRaw { get; set; } = "";
    public string transcript { get; set; } = "";
}

static class Program
{
    static async Task<int> Main(string[] args)
    {
        try
        {
            string? url = null;

           if (args.Length == 1 && !string.IsNullOrWhiteSpace(args[0]))
            {
                url = args[0];
            }
            else
            {
                // support stdin JSON: { "url": "https://..." }
                string stdin = Console.IsInputRedirected ? await Console.In.ReadToEndAsync() : "";
                if (!string.IsNullOrWhiteSpace(stdin))
                {
                    var input = JsonSerializer.Deserialize<Input>(stdin.Trim(),
                        new JsonSerializerOptions { PropertyNameCaseInsensitive = true });
                    url = input?.url;
                }
            }

           if (string.IsNullOrWhiteSpace(url))
            {
                Console.Error.WriteLine("Usage: ytx <YouTube URL>\n   or: echo '{\"url\":\"https://...\"}' | ytx");
                return 2;
            }

           var client = new YoutubeClient();
            var videoId = VideoId.TryParse(url) ?? throw new ArgumentException("Invalid YouTube URL/ID.");
            var video = await client.Videos.GetAsync(videoId);
            var title = video.Title ?? "";
            var description = video.Description ?? "";

           // captions
            string transcriptRaw = "";
            string transcriptMd = "";

           try
            {
                var manifest = await client.Videos.ClosedCaptions.GetManifestAsync(video.Id);

               // Prefer English (auto > manual doesn’t matter for our output), else first track available
                ClosedCaptionTrackInfo? track =
                    manifest.Tracks
                        .OrderByDescending(t => t.Language.Name?.Contains("English", StringComparison.OrdinalIgnoreCase) == true)
                        .ThenByDescending(t => t.IsAutoGenerated)
                        .FirstOrDefault();

               if (track != null)
                {
                    var captions = await client.Videos.ClosedCaptions.GetAsync(track);

                   // Build raw + markdown
                    var rawSb = new StringBuilder();
                    var mdSb  = new StringBuilder();

                   foreach (var c in captions.Captions)
                    {
                        var text = NormalizeCaption(c.Text);
                        if (string.IsNullOrWhiteSpace(text)) continue;

                       // raw
                        if (rawSb.Length > 0) rawSb.Append(' ');
                        rawSb.Append(text);

                       // markdown line with link
                        var ts = ToHhMmSs(c.Offset);
                        var link = $"https://www.youtube.com/watch?v={video.Id}&t={(int)c.Offset.TotalSeconds}s";
                        mdSb.AppendLine($"- [{ts}]({link}) {text}");
                    }

                   transcriptRaw = rawSb.ToString().Trim();
                    transcriptMd = mdSb.ToString().TrimEnd();
                }
                else
                {
                    transcriptRaw = "";
                    transcriptMd = "_No transcript/captions available for this video._";
                }
            }
            catch
            {
                // Captions often fail for restricted/disabled cases — fail soft.
                transcriptRaw = "";
                transcriptMd = "_No transcript/captions available or captions retrieval failed._";
            }

           var output = new Output
            {
                url = url,
                title = title,
                description = description,
                transcriptRaw = transcriptRaw,
                transcript = transcriptMd
            };

           var json = JsonSerializer.Serialize(output, new JsonSerializerOptions
            {
                WriteIndented = true,
                Encoder = System.Text.Encodings.Web.JavaScriptEncoder.UnsafeRelaxedJsonEscaping
            });

           Console.OutputEncoding = Encoding.UTF8;
            Console.WriteLine(json);
            return 0;
        }
        catch (Exception ex)
        {
            Console.Error.WriteLine($"Error: {ex.Message}");
            return 1;
        }
    }

   static string ToHhMmSs(TimeSpan ts)
    {
        int h = (int)ts.TotalHours;
        int m = ts.Minutes;
        int s = ts.Seconds;
        return h > 0 ? $"{h:00}:{m:00}:{s:00}" : $"{m:00}:{s:00}";
    }

   static string NormalizeCaption(string text)
    {
        if (string.IsNullOrWhiteSpace(text)) return "";
        // Collapse whitespace and strip styling markers commonly found in captions
        text = Regex.Replace(text, @"\s+", " ").Trim();
        text = text.Replace("&nbsp;", " ");
        return text;
    }
}
```

**`src/Ytx/Ytx.csproj`**

```xml
<Project Sdk="Microsoft.NET.Sdk">
  <PropertyGroup>
    <OutputType>Exe</OutputType>
    <TargetFrameworks>net8.0;net9.0</TargetFrameworks>
    <ImplicitUsings>enable</ImplicitUsings>
    <Nullable>enable</Nullable>

   <!-- Pack as a dotnet global tool -->
    <PackAsTool>true</PackAsTool>
    <ToolCommandName>ytx</ToolCommandName>
    <PackageId>Ytx.Tool</PackageId>
    <Version>1.0.0</Version>
    <Authors>You</Authors>
    <PackageOutputPath>../../nupkg</PackageOutputPath>
    <Description>Extract YouTube title, description, and full transcript (JSON output).</Description>
    <PackageLicenseExpression>MIT</PackageLicenseExpression>
  </PropertyGroup>

 <ItemGroup>
    <PackageReference Include="YoutubeExplode" Version="6.3.12" />
  </ItemGroup>
</Project>
```

### Build, pack, and install (local)

```bash
# from the folder containing /src/Ytx
dotnet restore src/Ytx
dotnet pack -c Release src/Ytx

# install the tool from the local nupkg folder
dotnet tool install --global Ytx.Tool --add-source ./nupkg

# usage
ytx "https://www.youtube.com/watch?v=dQw4w9WgXcQ"
# or
echo '{"url":"https://www.youtube.com/watch?v=dQw4w9WgXcQ"}' | ytx
```

> **Notes**
> 
> *   If a video has **no captions** (auto or manual), the tool returns the metadata and sets a human-readable note in `transcript`.
>     
> *   Works on macOS/Windows/Linux. .NET 8 or 9 SDK is fine.
>     

* * *

2) “One-liner” (shell) using `yt-dlp` + Python transcript lib
=============================================================

If you’d prefer a quick disposable pipeline without building anything:

Prereqs
-------

```bash
# macOS (Homebrew)
brew install yt-dlp jq uv

# python transcript lib (isolated with uvx)
uvx --from youtube-transcript-api youtube_transcript_api --help >/dev/null
```

One-liner function (bash/zsh)
-----------------------------

```bash
yt_json () {
  local URL="$1"
  if [ -z "$URL" ]; then echo "usage: yt_json <youtube_url>"; return 2; fi

 # 1) Get metadata (title/description/id) via yt-dlp (no download)
  local META
  META="$(yt-dlp -J --skip-download "$URL")" || { echo "yt-dlp failed"; return 1; }

 local ID TITLE DESC
  ID="$(jq -r '.id' <<<"$META")"
  TITLE="$(jq -r '.title' <<<"$META")"
  DESC="$(jq -r '.description // ""' <<<"$META")"

 # 2) Get transcript (English preferred, else first available)
  #    Produce both raw text and markdown with timestamp links.
  local PYOUT
  PYOUT="$(uvx --from youtube-transcript-api python - <<'PY' "$ID"
import json, sys
from youtube_transcript_api import YouTubeTranscriptApi, TranscriptsDisabled, NoTranscriptFound

vid = sys.argv[1]
def hms(seconds: int) -> str:
    h, rem = divmod(seconds, 3600)
    m, s = divmod(rem, 60)
    return f"{h:02d}:{m:02d}:{s:02d}" if h else f"{m:02d}:{s:02d}"

try:
    # Try English first, then any
    try:
        tlist = YouTubeTranscriptApi.get_transcript(vid, languages=['en'])
    except NoTranscriptFound:
        tlist = YouTubeTranscriptApi.get_transcript(vid)

   raw = " ".join(seg["text"].replace("\n"," ").strip() for seg in tlist if seg["text"].strip())
    md_lines = []
    for seg in tlist:
        txt = seg["text"].replace("\n"," ").strip()
        if not txt: continue
        ts  = int(seg["start"])
        md_lines.append(f"- [{hms(ts)}](https://www.youtube.com/watch?v={vid}&t={ts}s) {txt}")
    print(json.dumps({"raw": raw, "md": "\n".join(md_lines)}, ensure_ascii=False))
except (TranscriptsDisabled, NoTranscriptFound):
    print(json.dumps({"raw": "", "md": "_No transcript/captions available for this video._"}))
PY
  )" || { echo "transcript fetch failed"; return 1; }

 local RAW MD
  RAW="$(jq -r '.raw' <<<"$PYOUT")"
  MD="$(jq -r '.md' <<<"$PYOUT")"

 # 3) Emit final JSON
  jq -n --arg url "$URL" \
        --arg title "$TITLE" \
        --arg description "$DESC" \
        --arg transcriptRaw "$RAW" \
        --arg transcript "$MD" \
        '{url:$url,title:$title,description:$description,transcriptRaw:$transcriptRaw,transcript:$transcript}'
}
```

**Usage**

```bash
yt_json "https://www.youtube.com/watch?v=dQw4w9WgXcQ" > out.json
```

* * *

Output shape (example)
----------------------

```json
{
  "url": "https://www.youtube.com/watch?v=...",
  "title": "the video title",
  "description": "the video description",
  "transcriptRaw": "the transcript as one long string ...",
  "transcript": "- [00:03](https://www.youtube.com/watch?v=...&t=3s) First caption line\n- [00:07](...) Second caption line"
}
```

* * *

Why two options?
----------------

*   **.NET Global Tool** — native, fast, one binary you can keep on all machines; ideal for scripting and long-term use.
    
*   **Shell One-liner** — zero project setup; perfect when you just want JSON right now.
    

If you want a tiny **HTML page** to render the produced JSON nicely (paste JSON → get pretty view), I can add that too.

## User
Yes please to the html page and instructions on how to publish the dotnet tool to nuget including a GitHub actions workflow file that would publish a new version incrementing the csproj version on a successful build then push to nuget using a readme.md I want you to also wrote as tbe doc that nuget uses each version

## ChatGPT
Awesome — here’s everything you asked for: a tiny **HTML viewer** for your JSON, plus a ready-to-ship **NuGet publishing setup** (README, updated `.csproj`, and a GitHub Actions workflow that bumps the version, packs, and pushes).

* * *

A) Paste-and-View HTML (single file)
====================================

Save as `viewer.html` and just open it in any browser. Paste the JSON your tool outputs and it’ll render a clean page with copy/download actions. No external deps, fully offline.

```html
<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>YouTube JSON → Viewer</title>
<style>
  :root { --bg:#0b0f14; --card:#111826; --muted:#8892a6; --text:#e6edf3; --accent:#6ea8fe; }
  html,body{margin:0;padding:0;background:var(--bg);color:var(--text);font:14px/1.45 system-ui,-apple-system,Segoe UI,Roboto,Ubuntu,Cantarell,"Noto Sans",Arial;}
  header{padding:18px 16px;border-bottom:1px solid #1d2636;background:linear-gradient(180deg,#0b0f14,#0a111c);}
  h1{margin:0;font-size:18px;letter-spacing:.2px}
  main{max-width:1100px;margin:0 auto;padding:20px 12px 80px}
  .row{display:grid;gap:16px;grid-template-columns:1fr;align-items:start}
  @media(min-width:1000px){.row{grid-template-columns:420px 1fr}}
  .card{background:var(--card);border:1px solid #1d2636;border-radius:12px;padding:14px}
  .card h2{margin:0 0 10px 0;font-size:15px;color:#cbd5e1}
  textarea, input, button {font:inherit}
  textarea, input[type="file"]{width:100%;box-sizing:border-box;background:#0b121f;color:var(--text);border:1px solid #1d2636;border-radius:8px;padding:10px;outline:none}
  textarea:focus{border-color:#2b3a55}
  .btn{display:inline-flex;gap:8px;align-items:center;padding:8px 10px;border:1px solid #27324a;background:#0f172a;color:var(--text);border-radius:8px;cursor:pointer}
  .btn:hover{border-color:#334062}
  .stack{display:flex;gap:8px;flex-wrap:wrap}
  .muted{color:var(--muted)}
  .kv{display:grid;grid-template-columns:140px 1fr;gap:8px;align-items:start}
  .kv div:first-child{color:#9fb0cb}
  pre{white-space:pre-wrap;word-wrap:break-word;background:#0b121f;border:1px solid #1d2636;border-radius:8px;padding:12px;margin:0}
  .copy{float:right}
  .pill{display:inline-block;border:1px solid #2d3a56;padding:2px 8px;border-radius:999px;color:#c7d2fe;background:#0e1530}
  .footer{margin-top:16px;color:#8da2bf}
  .link a{color:var(--accent);text-decoration:none}
  .link a:hover{text-decoration:underline}
</style>
</head>
<body>
<header><h1>YouTube JSON → Viewer</h1></header>
<main>
  <div class="row">
    <section class="card">
      <h2>1) Paste JSON</h2>
      <textarea id="jsonIn" rows="14" placeholder='Paste the JSON from ytx or the shell one-liner here...'></textarea>
      <div class="stack" style="margin-top:10px">
        <button class="btn" id="loadBtn">Load</button>
        <label class="btn" for="file">Load .json <input id="file" type="file" accept="application/json" style="display:none"></label>
        <button class="btn" id="sampleBtn">Sample</button>
        <button class="btn" id="clearBtn">Clear</button>
      </div>
      <p class="footer muted">Expected shape:
        <span class="pill">url</span> <span class="pill">title</span> <span class="pill">description</span>
        <span class="pill">transcriptRaw</span> <span class="pill">transcript</span>
      </p>
    </section>

   <section class="card">
      <h2>2) Summary</h2>
      <div class="kv">
        <div>Title</div><div id="title" class="link">—</div>
        <div>URL</div><div id="url" class="link">—</div>
        <div>Description</div><div id="desc">—</div>
      </div>
    </section>

   <section class="card">
      <h2>Transcript (Markdown)</h2>
      <div class="stack" style="margin-bottom:8px">
        <button class="btn copy" data-target="mdOut">Copy</button>
        <button class="btn" id="downloadMd">Download .md</button>
      </div>
      <pre id="mdOut">—</pre>
    </section>

   <section class="card">
      <h2>Transcript (Raw)</h2>
      <div class="stack" style="margin-bottom:8px">
        <button class="btn copy" data-target="rawOut">Copy</button>
        <button class="btn" id="downloadJson">Download merged .json</button>
      </div>
      <pre id="rawOut">—</pre>
    </section>
  </div>
</main>

<script>
(function(){
  const $ = s => document.querySelector(s);
  const jsonIn = $("#jsonIn");
  const set = (id, html) => { const el = $("#"+id); el.innerHTML = html || "—"; };

 function loadObj(obj){
    try{
      set("title", obj.title ? `<a target="_blank" rel="noopener" href="${obj.url||'#'}">${escapeHtml(obj.title)}</a>` : "—");
      set("url", obj.url ? `<a target="_blank" rel="noopener" href="${obj.url}">${obj.url}</a>` : "—");
      set("desc", obj.description ? `<pre>${escapeHtml(obj.description)}</pre>` : "—");
      set("mdOut", obj.transcript ? escapeHtml(obj.transcript) : "—");
      set("rawOut", obj.transcriptRaw ? escapeHtml(obj.transcriptRaw) : "—");
      window.__lastObj = obj;
    }catch(e){ alert("Render error: " + e.message); }
  }

 function parseAndLoad(){
    try{
      const obj = JSON.parse(jsonIn.value);
      loadObj(obj);
    }catch(e){ alert("Invalid JSON: " + e.message); }
  }

 function escapeHtml(s){
    return String(s)
      .replaceAll("&","&amp;").replaceAll("<","&lt;").replaceAll(">","&gt;")
      .replaceAll('"',"&quot;").replaceAll("'","&#39;");
  }

 function download(name, mime, text){
    const blob = new Blob([text], {type: mime});
    const a = document.createElement("a");
    a.href = URL.createObjectURL(blob);
    a.download = name;
    document.body.appendChild(a); a.click(); a.remove();
    setTimeout(()=>URL.revokeObjectURL(a.href), 1500);
  }

 document.addEventListener("click", e=>{
    const t = e.target;
    if(t.classList.contains("copy")){
      const target = t.getAttribute("data-target");
      const data = $("#"+target).innerText;
      navigator.clipboard.writeText(data).then(()=>{ t.textContent="Copied!"; setTimeout(()=>t.textContent="Copy",1200); });
    }
  });

 $("#loadBtn").addEventListener("click", parseAndLoad);
  $("#clearBtn").addEventListener("click", ()=>{ jsonIn.value=""; set("title"); set("url"); set("desc"); set("mdOut"); set("rawOut"); window.__lastObj=null; });

 $("#file").addEventListener("change", async (e)=>{
    const f = e.target.files[0]; if(!f) return;
    const text = await f.text();
    jsonIn.value = text;
    parseAndLoad();
  });

 $("#downloadMd").addEventListener("click", ()=>{
    const obj = window.__lastObj; if(!obj) return alert("Load JSON first.");
    const base = (obj.title||"transcript").replace(/[^\w\-]+/g,"-").replace(/-+/g,"-");
    download(base + ".md", "text/markdown;charset=utf-8", obj.transcript || "");
  });

 $("#downloadJson").addEventListener("click", ()=>{
    const obj = window.__lastObj; if(!obj) return alert("Load JSON first.");
    const base = (obj.title||"video").replace(/[^\w\-]+/g,"-").replace(/-+/g,"-");
    download(base + ".json", "application/json;charset=utf-8", JSON.stringify(obj,null,2));
  });

 $("#sampleBtn").addEventListener("click", ()=>{
    const sample = {
      "url":"https://www.youtube.com/watch?v=dQw4w9WgXcQ",
      "title":"Sample Title",
      "description":"Sample description.",
      "transcriptRaw":"This is a raw transcript example…",
      "transcript":"- [00:03](https://www.youtube.com/watch?v=dQw4w9WgXcQ&t=3s) Intro line\n- [00:12](https://www.youtube.com/watch?v=dQw4w9WgXcQ&t=12s) Second line"
    };
    jsonIn.value = JSON.stringify(sample, null, 2);
    parseAndLoad();
  });
})();
</script>
</body>
</html>
```

* * *

B) NuGet publishing: project tweaks + README + GitHub Actions
=============================================================

Below is everything you can drop straight into your repo.

1) Update your `src/Ytx/Ytx.csproj`
-----------------------------------

Add metadata for NuGet and wire the README into the package. (Assumes `README.md` lives next to the `.csproj`.)

```xml
<Project Sdk="Microsoft.NET.Sdk">
  <PropertyGroup>
    <OutputType>Exe</OutputType>
    <TargetFrameworks>net8.0;net9.0</TargetFrameworks>
    <ImplicitUsings>enable</ImplicitUsings>
    <Nullable>enable</Nullable>

   <!-- Tool packaging -->
    <PackAsTool>true</PackAsTool>
    <ToolCommandName>ytx</ToolCommandName>
    <PackageId>Ytx.Tool</PackageId>

   <!-- Version will be auto-bumped by CI; keep a valid seed -->
    <Version>1.0.0</Version>

   <!-- NuGet metadata -->
    <Authors>John J Smith</Authors>
    <PackageDescription>Extract YouTube title, description, and transcript (raw + Markdown) as JSON.</PackageDescription>
    <PackageTags>YouTube;transcript;captions;cli;dotnet-tool;json</PackageTags>
    <RepositoryUrl>https://github.com/YOUR_ORG/ytx</RepositoryUrl>
    <PackageProjectUrl>https://github.com/YOUR_ORG/ytx</PackageProjectUrl>
    <PackageLicenseExpression>MIT</PackageLicenseExpression>
    <PackageReadmeFile>README.md</PackageReadmeFile>

   <!-- Put built nupkgs here; the workflow expects this -->
    <PackageOutputPath>../../nupkg</PackageOutputPath>
  </PropertyGroup>

 <ItemGroup>
    <PackageReference Include="YoutubeExplode" Version="6.3.12" />
  </ItemGroup>

 <!-- Ensure README is packed -->
  <ItemGroup>
    <None Include="README.md" Pack="true" PackagePath="\" />
  </ItemGroup>
</Project>
```

2) Add `src/Ytx/README.md` (the NuGet doc for every version)
------------------------------------------------------------

```markdown
# `ytx` — YouTube → JSON (title, description, transcript)

`ytx` is a .NET global tool that prints a single JSON object for any YouTube URL:

```json
{
  "url": "https://youtube.com/…",
  "title": "Video title",
  "description": "Video description…",
  "transcriptRaw": "Full transcript as one string…",
  "transcript": "- [00:03](https://www.youtube.com/watch?v=...&t=3s) First line\n- [00:07](...) Next line"
}
```

*   **Captions aware**: uses the best available caption track (prefers English if present; falls back to any).
    
*   **Human-readable transcript**: Markdown with timestamped links that jump to the exact moment on YouTube.
    
*   **Cross-platform**: macOS, Windows, Linux. Requires .NET 8 or 9 SDK at install time.
    

Install
-------

```bash
dotnet tool install -g Ytx.Tool
# later updates:
dotnet tool update -g Ytx.Tool
```

Usage
-----

```bash
ytx "https://www.youtube.com/watch?v=dQw4w9WgXcQ"

# or via stdin JSON
echo '{"url":"https://www.youtube.com/watch?v=dQw4w9WgXcQ"}' | ytx
```

Pipe to a file:

```bash
ytx "https://www.youtube.com/watch?v=dQw4w9WgXcQ" > out.json
```

JSON schema
-----------

*   `url` — input URL, echoed back.
    
*   `title` — video title.
    
*   `description` — full description text.
    
*   `transcriptRaw` — single string containing all caption text (whitespace-normalized).
    
*   `transcript` — Markdown bullets, each line: `- [HH:MM:SS](yt-link) text`.
    

> If no captions are available, `transcriptRaw` is empty and `transcript` explains that captions are unavailable.

Exit codes
----------

*   `0` success
    
*   `1` unexpected error (network/permission/etc.)
    
*   `2` usage error (missing/invalid URL)
    

Known limitations
-----------------

*   Private/age-restricted/region-blocked videos or videos with captions disabled will not include a transcript.
    
*   Timestamps are based on caption segment start times.
    

License
-------

MIT

```bash
## 3) GitHub Actions workflow: auto-bump version, pack, and publish to NuGet

Create `.github/workflows/publish.yml`:

```yaml
name: Publish NuGet (ytx)

on:
  workflow_dispatch:
    inputs:
      bump:
        description: 'Version bump type (major|minor|patch)'
        required: true
        default: 'patch'
  push:
    branches: [ "main" ]
    paths:
      - 'src/Ytx/**'
      - '.github/workflows/publish.yml'

permissions:
  contents: write   # allow committing the version bump and creating releases
  packages: read

env:
  PROJECT_DIR: src/Ytx
  CSPROJ: src/Ytx/Ytx.csproj
  NUPKG_DIR: nupkg
  NUGET_SOURCE: https://api.nuget.org/v3/index.json

jobs:
  build-pack-publish:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout
        uses: actions/checkout@v4

     - name: Setup .NET
        uses: actions/setup-dotnet@v4
        with:
          dotnet-version: |
            9.x
            8.x

     - name: Restore
        run: dotnet restore $PROJECT_DIR

     - name: Determine and bump version
        id: bump
        shell: bash
        run: |
          set -euo pipefail
          CURR=$(grep -oPm1 '(?<=<Version>)[^<]+' "$CSPROJ")
          echo "Current version: $CURR"
          IFS='.' read -r MAJ MIN PAT <<< "$CURR"
          BUMP="${{ github.event.inputs.bump || 'patch' }}"
          case "$BUMP" in
            major) MAJ=$((MAJ+1)); MIN=0; PAT=0 ;;
            minor) MIN=$((MIN+1)); PAT=0 ;;
            patch|*) PAT=$((PAT+1)) ;;
          esac
          NEW="$MAJ.$MIN.$PAT"
          echo "New version: $NEW"
          # update csproj
          sed -i "s|<Version>$CURR</Version>|<Version>$NEW</Version>|" "$CSPROJ"
          echo "version=$NEW" >> "$GITHUB_OUTPUT"

     - name: Commit version bump
        if: ${{ github.ref == 'refs/heads/main' }}
        run: |
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"
          git add ${{ env.CSPROJ }}
          git commit -m "chore: bump version to ${{ steps.bump.outputs.version }}"
          git tag "v${{ steps.bump.outputs.version }}"
          git push --follow-tags

     - name: Build
        run: dotnet build $PROJECT_DIR -c Release --no-restore

     - name: Pack
        run: dotnet pack $PROJECT_DIR -c Release --no-build

     - name: Publish to NuGet
        env:
          NUGET_API_KEY: ${{ secrets.NUGET_API_KEY }}
        run: |
          dotnet nuget push $NUPKG_DIR/*.nupkg \
            --api-key "$NUGET_API_KEY" \
            --source "$NUGET_SOURCE" \
            --skip-duplicate

     - name: Create GitHub Release
        uses: softprops/action-gh-release@v2
        with:
          tag_name: v${{ steps.bump.outputs.version }}
          name: ytx v${{ steps.bump.outputs.version }}
          generate_release_notes: true
```

### What this workflow does

*   Triggers on `push` to `main` (in the `src/Ytx` path) **or** manually via “Run workflow”.
    
*   **Bumps `<Version>` in the `.csproj`** (default = patch; you can choose major/minor in the manual dispatch).
    
*   Commits the bump, tags `vX.Y.Z`, builds, packs, and **publishes to NuGet** using `NUGET_API_KEY`.
    
*   Creates a GitHub Release for the tag with auto notes.
    

> **Setup**: add a repo secret named **`NUGET_API_KEY`** containing your NuGet API key (from nuget.org → your account → API Keys).

* * *

C) Quick “how to publish” checklist
===================================

1.  Add the updated `.csproj` and the `README.md` next to it (`src/Ytx/README.md`).
    
2.  Add the workflow file at `.github/workflows/publish.yml`.
    
3.  In GitHub → Settings → Secrets and variables → Actions → **New repository secret**:
    
    *   `NUGET_API_KEY` = your nuget.org API key.
        
4.  Push to `main` (or use **Run workflow** and choose bump type).
    
5.  Confirm:
    
    *   The workflow bumps version in `Ytx.csproj`
        
    *   Creates/updates `nupkg/`
        
    *   Publishes to NuGet (package page shows your README)
        
    *   Creates a GitHub Release tagged `vX.Y.Z`
        

* * *

D) Optional: “nice to haves”
============================

*   **Repo URL placeholders**: replace `YOUR_ORG/ytx` in the `.csproj` once you create the repo.
    
*   **Binary name**: you can rename `ToolCommandName` if you prefer (`yt-json`, `ytcap`, etc.).
    
*   **Tests**: if you add tests later, drop a `dotnet test` step into the workflow before “Pack”.
    
*   **Signed packages**: if your org needs signing, add a signing step prior to `pack`.
    

If you want, I can also drop this into a small repo layout for you (tree of files with everything in place) so you can copy-paste directly.

## User
Please

## ChatGPT
sweet — here’s a drop-in repo you can paste onto disk and push. it uses your preferred default branch name **master**, ships the HTML viewer, and includes a GitHub Actions workflow that bumps the version, builds, packs, and publishes to NuGet with your README baked into each release.

* * *

repo layout
===========

```css
ytx/
├─ src/
│  └─ Ytx/
│     ├─ Program.cs
│     ├─ Ytx.csproj
│     └─ README.md
├─ web/
│  └─ viewer.html
├─ .github/
│  └─ workflows/
│     └─ publish.yml
├─ .gitignore
├─ LICENSE
└─ README.md
```

* * *

top-level `README.md` (repo overview)
-------------------------------------

```markdown
# ytx — YouTube → JSON (title, description, transcript)

A .NET global tool that emits a single JSON object for any YouTube URL:

```json
{
  "url": "https://youtube.com/…",
  "title": "Video title",
  "description": "Video description…",
  "transcriptRaw": "Full transcript as one string…",
  "transcript": "- [00:03](https://www.youtube.com/watch?v=...&t=3s) First line\n- [00:07](...) Next line"
}
```

*   Captions-aware (prefers English; falls back to any)
    
*   Markdown transcript with timestamped links
    
*   Cross-platform (.NET 8/9)
    
*   Bonus: `web/viewer.html` to paste and view JSON offline
    

quick start
-----------

```bash
# clone
git clone https://github.com/YOUR_ORG/ytx.git
cd ytx

# build + pack locally
dotnet restore src/Ytx
dotnet pack -c Release src/Ytx

# install the tool from local nupkg
dotnet tool install -g Ytx.Tool --add-source ./nupkg

# try it
ytx "https://www.youtube.com/watch?v=dQw4w9WgXcQ" > out.json
```

### html viewer

Open `web/viewer.html` in a browser, paste `out.json`, and export Markdown or merged JSON.

ci publish
----------

On push to **master** (or manual dispatch), the workflow:

1.  bumps `<Version>` in `src/Ytx/Ytx.csproj` (patch by default),
    
2.  builds & packs,
    
3.  pushes to NuGet using `NUGET_API_KEY`,
    
4.  creates a GitHub Release `vX.Y.Z`.
    

Set repo secret **`NUGET_API_KEY`** (nuget.org → API Keys).

```yaml
---

## `.gitignore`

```gitignore
# dotnet
bin/
obj/
*.user
*.suo

# packages
nupkg/
*.nupkg

# os
.DS_Store
Thumbs.db

# editor
.vscode/
.idea/
```

* * *

`LICENSE` (MIT)
---------------

```text
MIT License

Copyright (c) 2025 John J Smith

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights…
[snip unchanged MIT text — paste your standard MIT license here]
```

_(replace the year/name as you like; keep full MIT text)_

* * *

`src/Ytx/Program.cs`
--------------------

```csharp
using System.Text;
using System.Text.Json;
using System.Text.RegularExpressions;
using YoutubeExplode;
using YoutubeExplode.Videos;
using YoutubeExplode.Videos.ClosedCaptions;

record Input(string url);

class Output
{
    public string url { get; set; } = "";
    public string title { get; set; } = "";
    public string description { get; set; } = "";
    public string transcriptRaw { get; set; } = "";
    public string transcript { get; set; } = "";
}

static class Program
{
    static async Task<int> Main(string[] args)
    {
        try
        {
            string? url = null;

           if (args.Length == 1 && !string.IsNullOrWhiteSpace(args[0]))
            {
                url = args[0];
            }
            else
            {
                string stdin = Console.IsInputRedirected ? await Console.In.ReadToEndAsync() : "";
                if (!string.IsNullOrWhiteSpace(stdin))
                {
                    var input = JsonSerializer.Deserialize<Input>(stdin.Trim(),
                        new JsonSerializerOptions { PropertyNameCaseInsensitive = true });
                    url = input?.url;
                }
            }

           if (string.IsNullOrWhiteSpace(url))
            {
                Console.Error.WriteLine("Usage: ytx <YouTube URL>\n   or: echo '{\"url\":\"https://...\"}' | ytx");
                return 2;
            }

           var client = new YoutubeClient();
            var videoId = VideoId.TryParse(url) ?? throw new ArgumentException("Invalid YouTube URL/ID.");
            var video = await client.Videos.GetAsync(videoId);
            var title = video.Title ?? "";
            var description = video.Description ?? "";

           string transcriptRaw = "";
            string transcriptMd = "";

           try
            {
                var manifest = await client.Videos.ClosedCaptions.GetManifestAsync(video.Id);
                var track = manifest.Tracks
                    .OrderByDescending(t => (t.Language?.Name?.Contains("English", StringComparison.OrdinalIgnoreCase) ?? false))
                    .ThenByDescending(t => t.IsAutoGenerated)
                    .FirstOrDefault();

               if (track != null)
                {
                    var captions = await client.Videos.ClosedCaptions.GetAsync(track);

                   var rawSb = new StringBuilder();
                    var mdSb  = new StringBuilder();

                   foreach (var c in captions.Captions)
                    {
                        var text = NormalizeCaption(c.Text);
                        if (string.IsNullOrWhiteSpace(text)) continue;

                       if (rawSb.Length > 0) rawSb.Append(' ');
                        rawSb.Append(text);

                       var ts = ToHhMmSs(c.Offset);
                        var link = $"https://www.youtube.com/watch?v={video.Id}&t={(int)c.Offset.TotalSeconds}s";
                        mdSb.AppendLine($"- [{ts}]({link}) {text}");
                    }

                   transcriptRaw = rawSb.ToString().Trim();
                    transcriptMd = mdSb.ToString().TrimEnd();
                }
                else
                {
                    transcriptRaw = "";
                    transcriptMd = "_No transcript/captions available for this video._";
                }
            }
            catch
            {
                transcriptRaw = "";
                transcriptMd = "_No transcript/captions available or captions retrieval failed._";
            }

           var output = new Output
            {
                url = url,
                title = title,
                description = description,
                transcriptRaw = transcriptRaw,
                transcript = transcriptMd
            };

           var json = JsonSerializer.Serialize(output, new JsonSerializerOptions
            {
                WriteIndented = true,
                Encoder = System.Text.Encodings.Web.JavaScriptEncoder.UnsafeRelaxedJsonEscaping
            });

           Console.OutputEncoding = Encoding.UTF8;
            Console.WriteLine(json);
            return 0;
        }
        catch (Exception ex)
        {
            Console.Error.WriteLine($"Error: {ex.Message}");
            return 1;
        }
    }

   static string ToHhMmSs(TimeSpan ts)
    {
        int h = (int)ts.TotalHours;
        int m = ts.Minutes;
        int s = ts.Seconds;
        return h > 0 ? $"{h:00}:{m:00}:{s:00}" : $"{m:00}:{s:00}";
    }

   static string NormalizeCaption(string text)
    {
        if (string.IsNullOrWhiteSpace(text)) return "";
        text = Regex.Replace(text, @"\s+", " ").Trim();
        text = text.Replace("&nbsp;", " ");
        return text;
    }
}
```

* * *

`src/Ytx/Ytx.csproj`
--------------------

```xml
<Project Sdk="Microsoft.NET.Sdk">
  <PropertyGroup>
    <OutputType>Exe</OutputType>
    <TargetFrameworks>net8.0;net9.0</TargetFrameworks>
    <ImplicitUsings>enable</ImplicitUsings>
    <Nullable>enable</Nullable>

   <!-- dotnet tool packaging -->
    <PackAsTool>true</PackAsTool>
    <ToolCommandName>ytx</ToolCommandName>
    <PackageId>Ytx.Tool</PackageId>

   <!-- CI auto-bumps this -->
    <Version>1.0.0</Version>

   <!-- NuGet metadata -->
    <Authors>John J Smith</Authors>
    <PackageDescription>Extract YouTube title, description, and transcript (raw + Markdown) as JSON.</PackageDescription>
    <PackageTags>YouTube;transcript;captions;cli;dotnet-tool;json</PackageTags>
    <RepositoryUrl>https://github.com/YOUR_ORG/ytx</RepositoryUrl>
    <PackageProjectUrl>https://github.com/YOUR_ORG/ytx</PackageProjectUrl>
    <PackageLicenseExpression>MIT</PackageLicenseExpression>
    <PackageReadmeFile>README.md</PackageReadmeFile>

   <!-- where pack puts .nupkg -->
    <PackageOutputPath>../../nupkg</PackageOutputPath>
  </PropertyGroup>

 <ItemGroup>
    <PackageReference Include="YoutubeExplode" Version="6.3.12" />
  </ItemGroup>

 <ItemGroup>
    <None Include="README.md" Pack="true" PackagePath="\" />
  </ItemGroup>
</Project>
```

* * *

`src/Ytx/README.md` (NuGet doc per version)
-------------------------------------------

```markdown
# `ytx` — YouTube → JSON (title, description, transcript)

`ytx` prints a single JSON object for a YouTube URL:

```json
{
  "url": "https://youtube.com/…",
  "title": "Video title",
  "description": "Video description…",
  "transcriptRaw": "Full transcript as one string…",
  "transcript": "- [00:03](https://www.youtube.com/watch?v=...&t=3s) First line\n- [00:07](...) Next line"
}
```

*   Prefers English captions; falls back to any available.
    
*   Markdown transcript with timestamped links.
    
*   Works on macOS, Windows, Linux (.NET 8/9).
    

Install
-------

```bash
dotnet tool install -g Ytx.Tool
# upgrades:
dotnet tool update -g Ytx.Tool
```

Usage
-----

```bash
ytx "https://www.youtube.com/watch?v=dQw4w9WgXcQ"
# or:
echo '{"url":"https://www.youtube.com/watch?v=dQw4w9WgXcQ"}' | ytx
```

JSON fields
-----------

*   `url` — input URL.
    
*   `title` — video title.
    
*   `description` — full description.
    
*   `transcriptRaw` — all caption text, normalized.
    
*   `transcript` — Markdown list with `[HH:MM(:SS)](yt?t=Ns) text`.
    

If captions are unavailable, `transcriptRaw` is empty and `transcript` states why.

Exit codes
----------

*   `0` success
    
*   `1` unexpected error
    
*   `2` usage error (missing/invalid URL)
    

License
-------

MIT

```bash
---

## `.github/workflows/publish.yml` (uses **master**)

```yaml
name: Publish NuGet (ytx)

on:
  workflow_dispatch:
    inputs:
      bump:
        description: 'Version bump type (major|minor|patch)'
        required: true
        default: 'patch'
  push:
    branches: [ "master" ]
    paths:
      - 'src/Ytx/**'
      - '.github/workflows/publish.yml'

permissions:
  contents: write
  packages: read

env:
  PROJECT_DIR: src/Ytx
  CSPROJ: src/Ytx/Ytx.csproj
  NUPKG_DIR: nupkg
  NUGET_SOURCE: https://api.nuget.org/v3/index.json

jobs:
  build-pack-publish:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout
        uses: actions/checkout@v4

     - name: Setup .NET
        uses: actions/setup-dotnet@v4
        with:
          dotnet-version: |
            9.x
            8.x

     - name: Restore
        run: dotnet restore $PROJECT_DIR

     - name: Determine and bump version
        id: bump
        shell: bash
        run: |
          set -euo pipefail
          CURR=$(grep -oPm1 '(?<=<Version>)[^<]+' "$CSPROJ")
          echo "Current version: $CURR"
          IFS='.' read -r MAJ MIN PAT <<< "$CURR"
          BUMP="${{ github.event.inputs.bump || 'patch' }}"
          case "$BUMP" in
            major) MAJ=$((MAJ+1)); MIN=0; PAT=0 ;;
            minor) MIN=$((MIN+1)); PAT=0 ;;
            patch|*) PAT=$((PAT+1)) ;;
          esac
          NEW="$MAJ.$MIN.$PAT"
          echo "New version: $NEW"
          sed -i "s|<Version>$CURR</Version>|<Version>$NEW</Version>|" "$CSPROJ"
          echo "version=$NEW" >> "$GITHUB_OUTPUT"

     - name: Commit version bump
        if: ${{ github.ref == 'refs/heads/master' }}
        run: |
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"
          git add ${{ env.CSPROJ }}
          git commit -m "chore: bump version to ${{ steps.bump.outputs.version }}"
          git tag "v${{ steps.bump.outputs.version }}"
          git push --follow-tags

     - name: Build
        run: dotnet build $PROJECT_DIR -c Release --no-restore

     - name: Pack
        run: dotnet pack $PROJECT_DIR -c Release --no-build

     - name: Publish to NuGet
        env:
          NUGET_API_KEY: ${{ secrets.NUGET_API_KEY }}
        run: |
          dotnet nuget push $NUPKG_DIR/*.nupkg \
            --api-key "$NUGET_API_KEY" \
            --source "$NUGET_SOURCE" \
            --skip-duplicate

     - name: Create GitHub Release
        uses: softprops/action-gh-release@v2
        with:
          tag_name: v${{ steps.bump.outputs.version }}
          name: ytx v${{ steps.bump.outputs.version }}
          generate_release_notes: true
```

* * *

`web/viewer.html` (paste-and-view tool)
---------------------------------------

> fully offline, single file, supports copy & downloads.

```html
<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8"><meta name="viewport" content="width=device-width,initial-scale=1">
<title>YouTube JSON → Viewer</title>
<style>
  :root { --bg:#0b0f14; --card:#111826; --muted:#8892a6; --text:#e6edf3; --accent:#6ea8fe; }
  html,body{margin:0;padding:0;background:var(--bg);color:var(--text);font:14px/1.45 system-ui,-apple-system,Segoe UI,Roboto,Ubuntu,Cantarell,"Noto Sans",Arial;}
  header{padding:18px 16px;border-bottom:1px solid #1d2636;background:linear-gradient(180deg,#0b0f14,#0a111c);}
  h1{margin:0;font-size:18px;letter-spacing:.2px}
  main{max-width:1100px;margin:0 auto;padding:20px 12px 80px}
  .row{display:grid;gap:16px;grid-template-columns:1fr}
  @media(min-width:1000px){.row{grid-template-columns:420px 1fr}}
  .card{background:var(--card);border:1px solid #1d2636;border-radius:12px;padding:14px}
  .card h2{margin:0 0 10px 0;font-size:15px;color:#cbd5e1}
  textarea,input,button{font:inherit}
  textarea,input[type=file]{width:100%;box-sizing:border-box;background:#0b121f;color:var(--text);border:1px solid #1d2636;border-radius:8px;padding:10px;outline:none}
  .btn{display:inline-flex;gap:8px;align-items:center;padding:8px 10px;border:1px solid #27324a;background:#0f172a;color:var(--text);border-radius:8px;cursor:pointer}
  .btn:hover{border-color:#334062}
  .stack{display:flex;gap:8px;flex-wrap:wrap}
  .muted{color:var(--muted)}
  .kv{display:grid;grid-template-columns:140px 1fr;gap:8px}
  .kv div:first-child{color:#9fb0cb}
  pre{white-space:pre-wrap;word-wrap:break-word;background:#0b121f;border:1px solid #1d2636;border-radius:8px;padding:12px;margin:0}
  .copy{float:right}
  .pill{display:inline-block;border:1px solid #2d3a56;padding:2px 8px;border-radius:999px;color:#c7d2fe;background:#0e1530}
</style>
</head>
<body>
<header><h1>YouTube JSON → Viewer</h1></header>
<main>
  <div class="row">
    <section class="card">
      <h2>1) Paste JSON</h2>
      <textarea id="jsonIn" rows="14" placeholder='Paste the JSON from ytx here...'></textarea>
      <div class="stack" style="margin-top:10px">
        <button class="btn" id="loadBtn">Load</button>
        <label class="btn">Load .json <input id="file" type="file" accept="application/json" style="display:none"></label>
        <button class="btn" id="sampleBtn">Sample</button>
        <button class="btn" id="clearBtn">Clear</button>
      </div>
      <p class="muted">Expected fields:
        <span class="pill">url</span> <span class="pill">title</span> <span class="pill">description</span>
        <span class="pill">transcriptRaw</span> <span class="pill">transcript</span>
      </p>
    </section>

   <section class="card">
      <h2>2) Summary</h2>
      <div class="kv">
        <div>Title</div><div id="title">—</div>
        <div>URL</div><div id="url">—</div>
        <div>Description</div><div id="desc">—</div>
      </div>
    </section>

   <section class="card">
      <h2>Transcript (Markdown) <button class="btn copy" data-target="mdOut">Copy</button></h2>
      <pre id="mdOut">—</pre>
      <div class="stack" style="margin-top:8px">
        <button class="btn" id="downloadMd">Download .md</button>
      </div>
    </section>

   <section class="card">
      <h2>Transcript (Raw) <button class="btn copy" data-target="rawOut">Copy</button></h2>
      <pre id="rawOut">—</pre>
      <div class="stack" style="margin-top:8px">
        <button class="btn" id="downloadJson">Download merged .json</button>
      </div>
    </section>
  </div>
</main>

<script>
const $ = s => document.querySelector(s);
const set = (id, html) => { const el = $("#"+id); el.innerHTML = html || "—"; };

function escapeHtml(s){
  return String(s).replaceAll("&","&amp;").replaceAll("<","&lt;").replaceAll(">","&gt;")
                  .replaceAll('"',"&quot;").replaceAll("'","&#39;");
}
function loadObj(obj){
  set("title", obj.title ? `<a target="_blank" rel="noopener" href="${obj.url||'#'}">${escapeHtml(obj.title)}</a>` : "—");
  set("url", obj.url ? `<a target="_blank" rel="noopener" href="${obj.url}">${obj.url}</a>` : "—");
  set("desc", obj.description ? `<pre>${escapeHtml(obj.description)}</pre>` : "—");
  set("mdOut", obj.transcript ? escapeHtml(obj.transcript) : "—");
  set("rawOut", obj.transcriptRaw ? escapeHtml(obj.transcriptRaw) : "—");
  window.__lastObj = obj;
}
function parseAndLoad(){
  try { loadObj(JSON.parse($("#jsonIn").value)); }
  catch(e){ alert("Invalid JSON: " + e.message); }
}
function download(name, mime, text){
  const blob = new Blob([text], {type: mime});
  const a = document.createElement("a");
  a.href = URL.createObjectURL(blob);
  a.download = name;
  document.body.appendChild(a); a.click(); a.remove();
  setTimeout(()=>URL.revokeObjectURL(a.href), 1500);
}
document.addEventListener("click", e=>{
  const t = e.target;
  if(t.classList.contains("copy")){
    const data = $("#"+t.getAttribute("data-target")).innerText;
    navigator.clipboard.writeText(data).then(()=>{ t.textContent="Copied!"; setTimeout(()=>t.textContent="Copy",1200); });
  }
});
$("#loadBtn").addEventListener("click", parseAndLoad);
$("#clearBtn").addEventListener("click", ()=>{ $("#jsonIn").value=""; set("title"); set("url"); set("desc"); set("mdOut"); set("rawOut"); window.__lastObj=null; });
$("#file").addEventListener("change", async (e)=>{ const f=e.target.files[0]; if(!f) return; $("#jsonIn").value = await f.text(); parseAndLoad(); });
$("#downloadMd").addEventListener("click", ()=>{ const o=window.__lastObj; if(!o) return alert("Load JSON first."); const base=(o.title||"transcript").replace(/[^\w\-]+/g,"-").replace(/-+/g,"-"); download(base+".md","text/markdown;charset=utf-8", o.transcript||""); });
$("#downloadJson").addEventListener("click", ()=>{ const o=window.__lastObj; if(!o) return alert("Load JSON first."); const base=(o.title||"video").replace(/[^\w\-]+/g,"-").replace(/-+/g,"-"); download(base+".json","application/json;charset=utf-8", JSON.stringify(o,null,2)); });
$("#sampleBtn").addEventListener("click", ()=>{ const s={"url":"https://www.youtube.com/watch?v=dQw4w9WgXcQ","title":"Sample Title","description":"Sample description.","transcriptRaw":"This is a raw transcript example…","transcript":"- [00:03](https://www.youtube.com/watch?v=dQw4w9WgXcQ&t=3s) Intro line\n- [00:12](https://www.youtube.com/watch?v=dQw4w9WgXcQ&t=12s) Second line"}; $("#jsonIn").value=JSON.stringify(s,null,2); parseAndLoad(); });
</script>
</body>
</html>
```

* * *

bootstrap & publish steps
=========================

```bash
# 0) create repo and set default branch to master (GitHub: Settings → Branches)
mkdir ytx && cd ytx

# 1) create files (paste from this message)
#    or initialize with dotnet then overwrite:
dotnet new tool-manifest -o .
dotnet new console -o src/Ytx
# (now replace Program.cs, Ytx.csproj, add README.md, etc.)

# 2) git init & first commit
git init
git checkout -b master
git add .
git commit -m "feat: initial ytx tool + viewer + CI"

# 3) push
git remote add origin git@github.com:YOUR_ORG/ytx.git
git push -u origin master

# 4) set NuGet secret in GitHub
#    GitHub → repo → Settings → Secrets and variables → Actions → New repository secret
#    name: NUGET_API_KEY, value: <your key from nuget.org>

# 5) trigger publish
#    Option A: push another commit to master (changes under src/Ytx/**)
#    Option B: Actions → Publish NuGet (ytx) → Run workflow → choose bump (major/minor/patch)
```

* * *

anything you want tweaked (different tool name, extra fields in JSON, or switching to `main` branch naming), say the word and I’ll slot it in.

